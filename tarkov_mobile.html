<html lang="es"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>√Årbol de quests - Escape from Tarkov 1.0</title>
  <style>
	  .toolbar-btn {
	  border: 1px solid #3b4252;
	  background: rgba(15,18,25,0.9);
	  color: var(--text);
	  font-size: 11px;
	  padding: 4px 8px;
	  border-radius: 999px;
	  cursor: pointer;
	  text-transform: uppercase;
	  letter-spacing: .06em;
	}
	.toolbar-btn:hover {
	  background: #222631;
	}
  
    :root {
      --bg: #111319;
      --card-bg: #1b1f2a;
      --card-border: #2a3140;
      --text: #e5e9f0;
      --muted: #9da5b4;
      --accent-prapor: #cc7845;      /* naranja Prapor */
      --accent-therapist: #4aa3ff;   /* azul claro Terapeuta */
      --accent-skier: #c58cff;       /* lila Skier */
      --accent-peacekeeper: #3d5fa7; /* azul oscuro Peacekeeper */
      --accent-ragman: #00bcd4;      /* turquesa Ragman (ya no rojo) */
      --accent-mechanic: #e0c04f;    /* amarillo Mechanic */
      --accent-jaeger: #a1887f;      /* marr√≥n Jaeger, bien distinto del resto */
      --accent-fence: #ff9b3a;       /* naranja claro Fence */
      --accent-ref: #283593;         /* azul √≠ndigo Ref (Arena) */
      --accent-lightkeeper: #b0bec5; /* gris azulado Lightkeeper */
      --accent-completed: #4caf50;   /* verde completada */
      --accent-in-progress: #e06c75; /* rojo/magenta en curso */
      --edge: #888;
      --node-width: 190px;
      --node-height: 66px;
      --shadow-soft: 0 6px 18px rgba(0,0,0,0.4);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,sans-serif;
      background: radial-gradient(circle at top,#171b23 0,#080a0f 55%,#000 100%);
      color: var(--text);
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 10px 18px;
      border-bottom: 1px solid #222631;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      background: linear-gradient(to right,#141823,#111319);
      box-shadow: 0 2px 12px rgba(0,0,0,0.5);
      z-index: 2;
    }

    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: .04em;
      text-transform: uppercase;
    }

    header .subtitle {
      font-size: 12px;
      color: var(--muted);
    }

    .toolbar {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
    }

    .badge {
      padding: 2px 6px;
      border-radius: 999px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: .06em;
      border: 1px solid #3b4252;
      color: var(--muted);
    }

    .legend {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend span {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      font-size: 12px;
      color: var(--muted);
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 3px;
    }

    .legend-dot.prapor { background: var(--accent-prapor); }
    .legend-dot.therapist { background: var(--accent-therapist); }
    .legend-dot.skier { background: var(--accent-skier); }
    .legend-dot.peacekeeper { background: var(--accent-peacekeeper); }
    .legend-dot.ragman { background: var(--accent-ragman); }
    .legend-dot.mechanic { background: var(--accent-mechanic); }
    .legend-dot.jaeger { background: var(--accent-jaeger); }
    .legend-dot.fence { background: var(--accent-fence); }
    .legend-dot.ref { background: var(--accent-ref); }
    .legend-dot.lightkeeper { background: var(--accent-lightkeeper); }
    .legend-dot.completed { background: var(--accent-completed); }
    .legend-dot.in-progress { background: var(--accent-in-progress); }

    .zoom-controls {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      background: rgba(15,18,25,0.9);
      border-radius: 999px;
      padding: 2px 6px;
      border: 1px solid #2a3140;
    }

    .zoom-btn {
      border: none;
      padding: 2px 6px;
      background: transparent;
      color: var(--text);
      cursor: pointer;
      font-size: 14px;
      line-height: 1;
    }

    .zoom-btn:hover {
      background: #222631;
      border-radius: 999px;
    }

    .zoom-label {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .06em;
    }

    main { flex: 1; display: flex; min-height: 0; }

    .graph-container {
	  flex: 1;
	  position: relative;
	  overflow: auto;              /* ya permite scroll en ambas direcciones */
	  background: radial-gradient(circle at 10% 0,#1b2234 0,#080a0f 35%,#050609 100%);
	}

	/* AUMENTAMOS el ancho del lienzo para forzar scroll horizontal */
	.graph-inner {
	  width: 8000px;      /* antes 2600 / 3000 */
	  height: 10000px;     /* un pel√≠n m√°s alto tambi√©n */
	  margin: 32px 0 32px 40px;  /* sin margen a la derecha */
	  position: relative;
	  transform-origin: 0 0;
	}

	svg#quest-svg {
	  width: 8000px;      /* que coincida con graph-inner */
	  height: 10000px;
	}

    .quest-node rect {
      rx: 9;
      ry: 9;
      stroke-width: 1.2;
      stroke: var(--card-border);
      fill: var(--card-bg);
      filter: drop-shadow(0 4px 12px rgba(0,0,0,0.65));
      cursor: pointer;
      transition: transform .12s ease-out,stroke .12s,fill .12s;
    }

    .quest-node.completed rect {
      fill: #1d3121;
      stroke: var(--accent-completed);
    }

    .quest-node.in-progress rect {
      fill: #30171a;
      stroke: var(--accent-in-progress);
    }


    .quest-node.prapor rect {
      stroke: var(--accent-prapor);
      fill: rgba(204,120,69,0.22);
    }

    .quest-node.therapist rect {
      stroke: var(--accent-therapist);
      fill: rgba(74,163,255,0.22);
    }

    .quest-node.skier rect {
      stroke: var(--accent-skier);
      fill: rgba(197,140,255,0.22);
    }

    .quest-node.peacekeeper rect {
      stroke: var(--accent-peacekeeper);
      fill: rgba(61,95,167,0.22);
    }

    .quest-node.ref rect {
      stroke: var(--accent-ref);
      fill: rgba(40,53,147,0.22);
    }

    .quest-node.lightkeeper rect {
      stroke: var(--accent-lightkeeper);
      fill: rgba(176,190,197,0.22);
    }

    .quest-node.ragman rect {
      stroke: var(--accent-ragman);
      fill: rgba(0,188,212,0.22);
    }

    .quest-node.mechanic rect {
      stroke: var(--accent-mechanic);
      fill: rgba(224,192,79,0.22);
    }

    .quest-node.jaeger rect {
      stroke: var(--accent-jaeger);
      fill: rgba(161,136,127,0.22);
    }

    .quest-node.fence rect {
      stroke: var(--accent-fence);
      fill: rgba(255,155,58,0.22);
    }


    .quest-node.selected rect {
      stroke: #ffd54f !important;
      stroke-width: 2.2;
    }

    .quest-node.completed rect {
      fill: #1d3121;
      stroke: var(--accent-completed);
    }

    .quest-node:hover rect {
      transform: translateY(-2px);
      stroke-width: 1.5;
    }

    .quest-node text {
	  fill: var(--text);
	  font-size: 10px;      /* antes 12px */
	  pointer-events: none;
	}

	.quest-node .node-level {
	  font-size: 9px;      /* antes 11px */
	  fill: #d2d7e3;
	  font-weight: 500;
	}

	.quest-node .node-trader {
	  font-size: 9px;      /* antes 11px */
	  fill: var(--muted);
	}

    .quest-node .node-check {
      font-size: 14px;
      fill: var(--accent-completed);
      font-weight: bold;
    }

    .quest-node .trader-portrait {
      pointer-events: none;
    }

    .quest-edge {
	  stroke: var(--edge);
	  stroke-width: 1.6;   /* antes 1.2: un pel√≠n m√°s gruesa para clics */
	  fill: none;      /* no rellenar la curva, s√≥lo trazo */
	  opacity: .8;
	}

	/* Flechas largas / especiales (requisitos que cruzan el √°rbol) */
	.quest-edge-special {
	  stroke: #f6c177;        /* doradito suave */
	  fill: none;             /* tambi√©n sin relleno, s√≥lo l√≠nea */
	  opacity: 0.9;
	  stroke-width: 1.8;      /* antes 1.4 */
	  stroke-dasharray: 4 3;  /* l√≠nea discontinua */
	}

/* En modo edici√≥n, hacemos las curvas a√∫n m√°s gruesas para facilitar el click */
body.edge-edit-mode .quest-edge {
	  stroke-width: 2.8;
}

body.edge-edit-mode .quest-edge-special {
	  stroke-width: 3.2;
}


    .edge-handle {
      fill: #111319;
      stroke: #ffd54f;
      stroke-width: 1.2;
      cursor: pointer;
      display: none;
    }

    .edge-handle.active {
      display: block;
    }

    .quest-edge-selected {
      stroke-width: 2.2;
      opacity: 1;
    }

    .selection-rect {
      fill: rgba(229,192,123,0.10);
      stroke: #e5c07b;
      stroke-width: 1;
      stroke-dasharray: 4 2;
      pointer-events: none;
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: none;
      z-index: 10;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 11;
      pointer-events: none;
    }

    .modal.open,
    .modal-backdrop.open {
      display: flex;
      pointer-events: auto;
    }

    .modal-card {
      width: 420px;
      max-height: 80vh;
      background: radial-gradient(circle at top,#22283a 0,#151822 45%,#12141d 100%);
      border-radius: 18px;
      box-shadow: var(--shadow-soft);
      border: 1px solid #2f3747;
      padding: 18px 20px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      color: var(--text);
      position: relative;
    }

    .modal-header {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      justify-content: space-between;
    }

    .modal-title-block { display: flex; flex-direction: column; gap: 2px; }

    .modal-title {
	  margin: 0;
	  font-size: 17px;
	  cursor: pointer;
	}
	
	.modal-title:hover {
	  text-decoration: underline;
	}


    .modal-trader {
      font-size: 12px;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: .08em;
    }

    .modal-chip {
      border-radius: 999px;
      padding: 2px 8px;
      border: 1px solid #3b4252;
      font-size: 11px;
      color: var(--muted);
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .modal-chip span.dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
    }

    .modal-chip .dot.prapor { background: var(--accent-prapor); }
    .modal-chip .dot.therapist { background: var(--accent-therapist); }
    .modal-chip .dot.skier { background: var(--accent-skier); }
    .modal-chip .dot.peacekeeper { background: var(--accent-peacekeeper); }
    .modal-chip .dot.ragman { background: var(--accent-ragman); }
    .modal-chip .dot.mechanic { background: var(--accent-mechanic); }
    .modal-chip .dot.jaeger { background: var(--accent-jaeger); }
    .modal-chip .dot.fence { background: var(--accent-fence); }
    .modal-chip .dot.ref { background: var(--accent-ref); }
    .modal-chip .dot.lightkeeper { background: var(--accent-lightkeeper); }
    .modal-chip .dot.completed { background: var(--accent-completed); }
    .modal-chip .dot.in-progress { background: var(--accent-in-progress); }

    .modal-close {
      border: none;
      background: transparent;
      color: var(--muted);
      font-size: 20px;
      cursor: pointer;
      padding: 0 0 0 6px;
      line-height: 1;
    }

    .modal-body {
      font-size: 13px;
      color: var(--muted);
      overflow-y: auto;
      padding-right: 4px;
    }

    .modal-body h3 {
      margin: 10px 0 4px;
      font-size: 13px;
      color: var(--text);
      text-transform: uppercase;
      letter-spacing: .08em;
    }

    .modal-body ul {
      margin: 0 0 6px 16px;
      padding: 0;
    }

    .modal-body li { margin-bottom: 2px; }

    .modal-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      font-size: 12px;
      margin-top: 6px;
    }

    .checkbox-row {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .checkbox-row.completed input {
      accent-color: var(--accent-completed);
    }

    .checkbox-row.in-progress input {
      accent-color: var(--accent-in-progress);
    }

    .modal-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 2px;
      align-items: flex-start;
    }

    .yt-link { font-size: 12px; text-align: right; }

    .yt-link a {
      color: #ffb347;
      text-decoration: none;
    }

    .yt-link a:hover { text-decoration: underline; }

    .hint {
      font-size: 11px;
      color: var(--muted);
      margin-top: 2px;
    }

    @media (max-width: 900px) {
      .graph-inner,
      svg#quest-svg {
        width: 1400px;
      }
    }

    @media (max-width: 500px) {
      .modal-card { width: 95vw; }
    }
  
    .quest-node.in-progress rect {
      fill: #30171a;
      stroke: var(--accent-in-progress);
    }

  
    .level-filter {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(15,18,25,0.9);
      border: 1px solid #2a3140;
      font-size: 11px;
      color: var(--muted);
    }

    .level-filter .level-label {
      text-transform: uppercase;
      letter-spacing: .06em;
      font-size: 10px;
    }

    .level-input {
      width: 44px;
      padding: 2px 4px;
      background: transparent;
      border: none;
      border-bottom: 1px solid #3b4252;
      color: var(--text);
      font-size: 11px;
      outline: none;
      text-align: center;
    }

    .level-input::placeholder {
      color: #4c566a;
    }

    .level-input:focus {
      border-bottom-color: #88c0d0;
    }

    .quest-node.dim-level rect {
      opacity: 0.25;
    }

    .quest-node.dim-level text,
    .quest-node.dim-level .trader-portrait {
      opacity: 0.35;
    }

    .edge-edit-indicator {
      position: fixed;
      right: 18px;
      bottom: 18px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid #f6c177;
      background: rgba(15, 18, 25, 0.92);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.6);
      font-size: 11px;
      letter-spacing: .06em;
      text-transform: uppercase;
      color: #f6c177;
      opacity: 0;
      transform: translateY(4px);
      pointer-events: none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 20;
    }

    .edge-edit-indicator.active {
      opacity: 1;
      transform: translateY(0);
    }

    .trader-filter {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(15,18,25,0.9);
      border: 1px solid #2a3140;
      font-size: 11px;
      color: var(--muted);
    }

    .trader-select {
      background: transparent;
      border: none;
      color: var(--text);
      font-size: 11px;
      outline: none;
    }

    .search-box {
      display: inline-flex;
      align-items: center;
      margin-left: 12px;
    }

    .search-input {
      padding: 3px 6px;
      border-radius: 999px;
      border: 1px solid #3b4252;
      background: rgba(15,18,25,0.9);
      color: var(--text);
      font-size: 11px;
      outline: none;
      min-width: 160px;
    }

    .search-input::placeholder {
      color: #4c566a;
    }

    .help-btn {
      margin-left: 8px;
      padding: 2px 7px;
      font-size: 12px;
      border-radius: 999px;
    }

    .help-panel {
      position: fixed;
      left: 18px;
      bottom: 18px;
      max-width: 380px;
      padding: 10px 12px;
      background: rgba(15,18,25,0.96);
      border-radius: 12px;
      border: 1px solid #3b4252;
      box-shadow: 0 0 0 1px rgba(0,0,0,0.6);
      font-size: 11px;
      color: var(--text);
      z-index: 25;
      display: none;
    }

    .help-panel.active {
      display: block;
    }

    .help-panel h3 {
      margin: 0 0 6px;
      font-size: 12px;
    }

    .help-panel ul {
      margin: 0;
      padding-left: 16px;
    }

    .help-panel li {
      margin-bottom: 2px;
    }

    .quest-node.search-hit rect {
      stroke: #88c0d0;
      stroke-width: 2.2;
    }

    .quest-node.relation-center {
      filter: drop-shadow(0 0 4px rgba(246,193,119,0.8));
    }

    .quest-node.relation-pre {
      filter: drop-shadow(0 0 4px rgba(136,192,208,0.8));
    }

    .quest-node.relation-post {
      filter: drop-shadow(0 0 4px rgba(208,135,112,0.8));
    }

    @media (max-width: 900px) {
      header {
        flex-direction: column;
        align-items: flex-start;
        gap: 8px;
      }
      .toolbar {
        flex-wrap: wrap;
        row-gap: 6px;
        column-gap: 6px;
      }
      .zoom-controls {
        margin-left: 0;
        margin-top: 4px;
      }
      .graph-container {
        height: calc(100vh - 150px);
      }
    }
</style>
</head>
<body>
<header>
  <div>
    <h1>√Årbol de quests ‚Äì Tarkov 1.0</h1>
    <div class="subtitle">Progreso guardado en el HTML y en el archivo quests_data.js.</div>
  </div>
  <div class="toolbar">
    <div class="legend">
      <span><span class="legend-dot prapor"></span> Prapor</span>
      <span><span class="legend-dot therapist"></span> Terapeuta</span>
      <span><span class="legend-dot skier"></span> Skier</span>
      <span><span class="legend-dot peacekeeper"></span> Peacekeeper</span>
      <span><span class="legend-dot ragman"></span> Ragman</span>
      <span><span class="legend-dot mechanic"></span> Mechanic</span>
      <span><span class="legend-dot jaeger"></span> Jaeger</span>
      <span><span class="legend-dot fence"></span> Fence</span>
      <span><span class="legend-dot ref"></span> Ref</span>
      <span><span class="legend-dot lightkeeper"></span> Lightkeeper</span>
      <span><span class="legend-dot completed"></span> Completada</span>
      <span><span class="legend-dot in-progress"></span> En curso</span>
	  <button class="toolbar-btn" id="save-html">Guardar HTML</button>
	  <button class="toolbar-btn" id="save-quests-js">Guardar quests_data.txt</button>

    <div class="level-filter">
      <span class="level-label">Nv.</span>
      <input type="number" id="min-level" class="level-input" placeholder="min" min="1" max="70">
      <span>‚Äì</span>
      <input type="number" id="max-level" class="level-input" placeholder="max" min="1" max="70">
    </div>

    <div class="trader-filter">
      <span class="level-label">Trader</span>
      <select id="trader-filter" class="trader-select">
        <option value="">Todos</option>
        <option value="Prapor">Prapor</option>
        <option value="Terapeuta">Terapeuta</option>
        <option value="Skier">Skier</option>
        <option value="Peacekeeper">Peacekeeper</option>
        <option value="Mechanic">Mechanic</option>
        <option value="Ragman">Ragman</option>
        <option value="Jaeger">Jaeger</option>
        <option value="Fence">Fence</option>
        <option value="Ref">Ref</option>
        <option value="Lightkeeper">Lightkeeper</option>
        <option value="BTR Driver">BTR Driver</option>
      </select>
    </div>

    <div class="search-box">
      <input type="text" id="quest-search" class="search-input" placeholder="Buscar quest...">
    </div>

    <button class="toolbar-btn help-btn" id="help-toggle">?</button>
</div>
    <div class="zoom-controls">
      <button class="zoom-btn" id="zoom-out">‚àí</button>
      <span class="zoom-label">Zoom</span>
      <button class="zoom-btn" id="zoom-in">+</button>
    </div>
  </div>
</header>

<main>
  <div class="graph-container" id="graph-container">
    <div class="graph-inner" id="graph-inner" style="transform: scale(1);">
      <svg id="quest-svg"></svg></svg>
    </div>
  </div>
</main>
<div id="edge-edit-indicator" class="edge-edit-indicator">
  Modo edici√≥n de curvas (E)
</div>

<div class="help-panel" id="help-panel">
  <h3>Ayuda r√°pida</h3>
  <ul>
    <li><b>Click</b> en una quest: seleccionarla.</li>
    <li><b>Ctrl</b> + click: a√±adir/quitar de la selecci√≥n.</li>
    <li><b>Ctrl + arrastre</b> en el fondo: seleccionar por ventana.</li>
    <li><b>Ctrl + Shift + click</b> en una quest: seleccionar toda la cadena conectada.</li>
    <li><b>Doble click</b> en una quest: abrir detalles.</li>
    <li><b>Ctrl + Z</b>: deshacer √∫ltimo movimiento/curva.</li>
    <li><b>E</b>: entrar/salir de modo edici√≥n de curvas.</li>
    <li>En modo edici√≥n: click en una flecha ‚Üí editar su curva.</li>
    <li>En modo edici√≥n: Shift + click en una flecha ‚Üí devolverla a l√≠nea recta.</li>
    <li>Filtro de nivel: muestra destacadas solo las quests dentro del rango.</li>
    <li>Filtro de trader: muestra destacadas solo las quests del vendedor elegido.</li>
    <li>Buscar: centra y resalta la quest cuyo nombre contenga el texto.</li>
  </ul>
</div>
  Modo edici√≥n de curvas (E)
</div>


<div class="modal-backdrop" id="modal-backdrop"></div>
<div class="modal" id="quest-modal">
  <div class="modal-card">
    <div class="modal-header">
      <div class="modal-title-block">
        <h2 class="modal-title" id="modal-title">37. M√°s all√° de la carne roja ‚Äì Parte 2 (Beyond the Red Meat ‚Äì Part 2)</h2>
        <div class="modal-trader" id="modal-trader">Skier</div>
        <div class="modal-chip" id="modal-chip">
          <span class="dot skier"></span><span id="modal-chip-text">Pendiente</span>
        </div>
      </div>
      <button class="modal-close" id="modal-close" aria-label="Cerrar">√ó</button>
    </div>
    <div class="modal-body">
      <p id="modal-desc">Siguiendo la pista del diario del chef, Skier quiere que encuentres el aditivo qu√≠mico secreto que usaba TerraGroup en sus oficinas de Streets of Tarkov.</p>
      <h3>Objetivos</h3>
      <ul id="modal-objectives"><li>Localizar las oficinas de TerraGroup en Streets of Tarkov.</li><li>Encontrar EN RAID el componente qu√≠mico secreto (vial rojo).</li><li>Entregar el aditivo qu√≠mico a Skier.</li></ul>
      <h3>Recompensas</h3>
      <ul id="modal-rewards"><li>+21 300 EXP.</li><li>+0.03 reputaci√≥n con Skier.</li><li>120 000 rublos (126 000 / 138 000 con Centro de inteligencia).</li><li>1√ó fusil de asalto SIG MCX .300 Blackout.</li><li>3√ó cargador STANAG de 30 balas para AR-15 5,56√ó45.</li><li>3√ó paquete de 50 cartuchos .300 Blackout CBJ.</li><li>Desbloquea compra del grip t√°ctico Zenit RK-1 en montura B-25U en Skier LL4.</li></ul>
      <div class="modal-footer">
        <div class="modal-checkboxes">
          <label class="checkbox-row completed">
            <input type="checkbox" id="modal-completed">
            Quest completada
          </label>
          <label class="checkbox-row in-progress">
            <input type="checkbox" id="modal-inprogress">
            Quest en curso
          </label>
        </div>
        <div class="yt-link">
          V√≠deo gu√≠a:
          <a id="modal-youtube" href="https://www.youtube.com/watch?v=authZNaJERE" target="_blank" rel="noopener">Abrir en YouTube</a>
          <div class="hint">Se abre en una pesta√±a nueva.</div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="quests_data.js"></script>
<script>


  // =========================
  //   L√≥gica de render
  // =========================
  const STORAGE_KEY = "tarkov_quest_progress_v1_demo";
  const INPROG_KEY  = "tarkov_quest_inprogress_v1_demo";
  const LAYOUT_KEY  = "tarkov_quest_layout_v1_demo";
  const EDGE_LAYOUT_KEY = "tarkov_quest_edge_layout_v1_demo";
  // Datos iniciales de progreso y curvas (se guardan dentro del propio HTML)
  window.INITIAL_COMPLETION = {"sanitary-standards-2":true,"sanitary-standards-1":true,"shortage":true,"operation-aquarius-1":true,"painkiller":true,"operation-aquarius-2":true,"first-in-line":true,"easy-money-part-2":true,"balancing-part-1":true,"burning-rubber":true,"easy-money-part-1":true,"supplier":true,"acquaintance":true,"saving-the-mole":true,"gunsmith-part-1":true};
  window.INITIAL_INPROGRESS = {"pharmacist":true,"balancing-part-2":true,"provide-viewership":true,"friend-from-the-west-1":true,"the-extortionist":true,"gunsmith-part-3":true,"gunsmith-part-2":true,"farming-part-1":true};
  window.INITIAL_EDGE_LAYOUT = {"chemical-part-4->out-of-curiosity":{"cx":2079.5,"cy":1347.7578125},"getting-acquainted->information-source":{"cx":3950.015625,"cy":8277.0390625},"knock-knock->keepers-word":{"cx":3674.015625,"cy":8295.0390625},"scout->huntsman-factory-chief":{"cx":2458.111328125,"cy":6232.11474609375},"hunting-trip->northern-connections":{"cx":2763.33349609375,"cy":4519.33349609375},"silent-caliber->northern-connections":{"cx":2038.666748046875,"cy":4741},"fishing-gear->samples":{"cx":2472.666748046875,"cy":4291.33349609375},"revision-streets-of-tarkov->worst-job-in-the-world":{"cx":3677.015625,"cy":3767.0625},"friend-from-the-west-1->friend-from-the-west-2":{"cx":732.015625,"cy":2724.5390625},"whats-on-the-flash-drive->shady-business":{"cx":623.015625,"cy":4900.5390625},"tarkov-shooter-part-3->huntsman-secured-perimeter":{"cx":1635.015625,"cy":5497.5390625},"huntsman-secured-perimeter->huntsman-forest-cleaning":{"cx":338.015625,"cy":5875.5390625},"gunsmith-part-3->insider":{"cx":2803.515625,"cy":6837.5390625},"sales-night->huntsman-sellout":{"cx":1996.515625,"cy":6088.5390625},"inevitable-response->order-from-outside":{"cx":3635.015625,"cy":9539.0625},"anesthesia->samples":{"cx":4181.015625,"cy":4280.0625},"pharmacist->health-care-privacy-1":{"cx":1252,"cy":1157},"easy-money-part-1->easy-money-part-2":{"cx":614,"cy":164},"kind-of-sabotage->dangerous-road":{"cx":1908,"cy":860.6666641235352},"pharmacist->kind-of-sabotage":{"cx":1482,"cy":519.6666641235352},"pharmacist->car-repair":{"cx":1430,"cy":976.6666641235352},"pharmacist->general-wares":{"cx":1457,"cy":890.6666641235352},"pharmacist->supply-plans":{"cx":1470,"cy":838.6666641235352},"chemical-part-1->polikhim-hobo":{"cx":1474,"cy":1680.666748046875},"chemical-part-4->big-customer":{"cx":2222,"cy":1715.666748046875},"chemical-part-4->secure-corridor":{"cx":2949,"cy":1430.666748046875},"big-customer->secure-corridor":{"cx":3176,"cy":1804.666748046875}};

  const nodeWidth = 200;
  const nodeHeight = 65;
  const svg = document.getElementById("quest-svg");
  const ns = "http://www.w3.org/2000/svg";
  const completionState = loadCompletion();
  const inProgressState = loadInProgress();
  const edgeLayout = loadEdgeLayout();
  const questsById = {};
  quests.forEach(q => { questsById[q.id] = q; });

  // --- Edici√≥n de curvas ---
  let currentEditedEdgeKey = null;

  function selectEdgeForEditing(edgeKey) {
    currentEditedEdgeKey = edgeKey;

    // Quitar selecci√≥n anterior
    svg.querySelectorAll(".quest-edge-selected").forEach(el => {
      el.classList.remove("quest-edge-selected");
    });
    svg.querySelectorAll(".edge-handle.active").forEach(h => {
      h.classList.remove("active");
    });

    // Marcar la nueva flecha seleccionada
    svg.querySelectorAll(`.quest-edge[data-edge-key="${edgeKey}"]`).forEach(el => {
      el.classList.add("quest-edge-selected");
    });

    // Activar su handle
    const handle = svg.querySelector(`.edge-handle[data-edge-key="${edgeKey}"]`);
    if (handle) {
      handle.classList.add("active");
    }
  }

  // --- Filtro por nivel + trader ---
  let currentMinLevel = null;
  let currentMaxLevel = null;
  let currentTraderFilter = "";

  function applyLevelFilter() {
    const nodes = svg.querySelectorAll(".quest-node");
    nodes.forEach(g => {
      const id = g.dataset.id;
      const q = questsById[id];
      if (!q) return;
      const lvl = (q.nivel != null) ? q.nivel : null;
      const trader = q.trader || "";

      let dim = false;

      if (currentMinLevel != null) {
        if (lvl == null || lvl < currentMinLevel) dim = true;
      }
      if (currentMaxLevel != null) {
        if (lvl == null || lvl > currentMaxLevel) dim = true;
      }

      if (currentTraderFilter && trader !== currentTraderFilter) {
        dim = true;
      }

      g.classList.toggle("dim-level", dim);
    });
  }

  function setupLevelFilterUI() {
    const minInput = document.getElementById("min-level");
    const maxInput = document.getElementById("max-level");
    const traderSelect = document.getElementById("trader-filter");
    if (!minInput || !maxInput) return;

    function parseVal(v) {
      if (v === "" || v == null) return null;
      const n = parseInt(v, 10);
      return Number.isNaN(n) ? null : n;
    }

    function onChangeLevel() {
      currentMinLevel = parseVal(minInput.value);
      currentMaxLevel = parseVal(maxInput.value);
      applyLevelFilter();
    }

    minInput.addEventListener("input", onChangeLevel);
    maxInput.addEventListener("input", onChangeLevel);

    if (traderSelect) {
      traderSelect.addEventListener("change", () => {
        currentTraderFilter = traderSelect.value || "";
        applyLevelFilter();
      });
    }
  }


  // --- B√∫squeda de quests por nombre ---
  let currentSearchTerm = "";
  let currentSearchId = null;

  function clearSearchHighlight() {
    svg.querySelectorAll(".quest-node.search-hit").forEach(g => {
      g.classList.remove("search-hit");
    });
  }

  function centerViewOnQuest(id) {
    const node = svg.querySelector(`.quest-node[data-id="${id}"]`);
    const container = document.getElementById("graph-container");
    const inner = document.getElementById("graph-inner");
    if (!node || !container || !inner) return;

    const rect = node.getBoundingClientRect();
    const innerRect = inner.getBoundingClientRect();
    const contRect = container.getBoundingClientRect();

    const nodeCenterX = rect.left + rect.width / 2;
    const nodeCenterY = rect.top + rect.height / 2;

    const offsetX = nodeCenterX - innerRect.left;
    const offsetY = nodeCenterY - innerRect.top;

    const targetScrollLeft = offsetX - contRect.width / 2;
    const targetScrollTop = offsetY - contRect.height / 2;

    container.scrollTo({
      left: targetScrollLeft,
      top: targetScrollTop,
      behavior: "smooth"
    });
  }

  function setupSearchUI() {
    const input = document.getElementById("quest-search");
    if (!input) return;

    input.addEventListener("input", () => {
      const term = input.value.trim().toLowerCase();
      currentSearchTerm = term;
      clearSearchHighlight();
      currentSearchId = null;
      if (!term) return;

      const match = quests.find(q => (q.nombre || "").toLowerCase().includes(term));
      if (!match) return;
      currentSearchId = match.id;
      const node = svg.querySelector(`.quest-node[data-id="${match.id}"]`);
      if (node) {
        node.classList.add("search-hit");
        centerViewOnQuest(match.id);
      }
    });
  }

  // --- √çndices para relaciones entre quests (prereqs y sucesoras) ---
  const childrenById = {};
  quests.forEach(q => {
    (q.prereqIds || []).forEach(pid => {
      if (!childrenById[pid]) childrenById[pid] = [];
      childrenById[pid].push(q.id);
    });
  });

  function collectAncestors(id, acc) {
    acc = acc || new Set();
    const q = questsById[id];
    if (!q || !q.prereqIds) return acc;
    q.prereqIds.forEach(pid => {
      if (!acc.has(pid)) {
        acc.add(pid);
        collectAncestors(pid, acc);
      }
    });
    return acc;
  }

  function collectDescendants(id, acc) {
    acc = acc || new Set();
    const children = childrenById[id] || [];
    children.forEach(cid => {
      if (!acc.has(cid)) {
        acc.add(cid);
        collectDescendants(cid, acc);
      }
    });
    return acc;
  }

  function clearRelationHighlight() {
    svg.querySelectorAll(".quest-node").forEach(g => {
      g.classList.remove("relation-center", "relation-pre", "relation-post");
    });
  }

  function highlightRelations(centerId) {
    clearRelationHighlight();
    if (!centerId) return;
    const ancestors = collectAncestors(centerId, new Set());
    const descendants = collectDescendants(centerId, new Set());

    svg.querySelectorAll(".quest-node").forEach(g => {
      const id = g.dataset.id;
      if (id === centerId) {
        g.classList.add("relation-center");
      } else if (ancestors.has(id)) {
        g.classList.add("relation-pre");
      } else if (descendants.has(id)) {
        g.classList.add("relation-post");
      }
    });
  }

  // --- Retratos de traders ---
  const traderPortraits = {
    "Prapor":       "img/prapor.png",
    "Terapeuta":    "img/therapist.png",
    "Skier":        "img/skier.png",
    "Peacekeeper":  "img/peacekeeper.png",
    "Mechanic":     "img/mechanic.png",
    "Ragman":       "img/ragman.png",
    "Jaeger":       "img/jaeger.png",
    "Fence":        "img/fence.png",
    "Ref":          "img/ref.png",
    "Lightkeeper":  "img/lightkeeper.png",
    "BTR Driver":   "img/btr_driver.png"
  };

  // Calculamos la primera quest de cada trader (preferimos quests sin prereqs y con nivel m√°s bajo)
  const firstQuestByTrader = {};
  quests.forEach(q => {
    if (!q.trader) return;
    const t = q.trader;
    const current = firstQuestByTrader[t];
    const prereq = Array.isArray(q.prereqIds) ? q.prereqIds : [];
    const isRoot = prereq.length === 0;

    if (!current) {
      firstQuestByTrader[t] = q;
      return;
    }

    const currentPrereq = Array.isArray(current.prereqIds) ? current.prereqIds : [];
    const currentIsRoot = currentPrereq.length === 0;

    if (!currentIsRoot && isRoot) {
      firstQuestByTrader[t] = q;
      return;
    }

    const lvl = (q.nivel != null) ? q.nivel : 999;
    const currLvl = (current.nivel != null) ? current.nivel : 999;
    if (isRoot === currentIsRoot && lvl < currLvl) {
      firstQuestByTrader[t] = q;
    }
  });

  // Clip circular para retratos
  let defs = svg.querySelector("defs");
  if (!defs) {
    defs = document.createElementNS(ns, "defs");
    svg.appendChild(defs);
  }
  let portraitClip = defs.querySelector("#portrait-clip");
  if (!portraitClip) {
    portraitClip = document.createElementNS(ns, "clipPath");
    portraitClip.setAttribute("id", "portrait-clip");
    // Usamos unidades relativas al bounding box del <image>
    portraitClip.setAttribute("clipPathUnits", "objectBoundingBox");
    const circle = document.createElementNS(ns, "circle");
    circle.setAttribute("cx", 0.5);
    circle.setAttribute("cy", 0.5);
    circle.setAttribute("r", 0.5);
    portraitClip.appendChild(circle);
    defs.appendChild(portraitClip);
  }

	  // Cargar layout guardado (si existe) y aplicado al HTML
  function loadCompletion() {
    try {
      // Clonamos los datos iniciales embebidos en el propio HTML
      const base = window.INITIAL_COMPLETION || {};
      return JSON.parse(JSON.stringify(base));
    } catch (e) {
      console.warn("No se pudo cargar progreso desde HTML:", e);
      return {};
    }
  }

  function saveCompletion() {
    try {
      // Mantener sincronizado con la variable global para que se vuelque al guardar el HTML
      window.INITIAL_COMPLETION = completionState;
    } catch (e) {
      console.warn("No se pudo guardar progreso en memoria HTML:", e);
    }
  }


  function loadEdgeLayout() {
    try {
      // Clonamos los datos iniciales embebidos en el propio HTML
      const base = window.INITIAL_EDGE_LAYOUT || {};
      return JSON.parse(JSON.stringify(base));
    } catch (e) {
      console.warn("No se pudo cargar layout de edges desde HTML:", e);
      return {};
    }
  }

  function saveEdgeLayout() {
    // Mantener en memoria sincronizado con la variable global
    window.INITIAL_EDGE_LAYOUT = edgeLayout;
  }

  function loadInProgress() {
    try {
      // Clonamos los datos iniciales embebidos en el propio HTML
      const base = window.INITIAL_INPROGRESS || {};
      return JSON.parse(JSON.stringify(base));
    } catch (e) {
      console.warn("No se pudo cargar estado 'en curso' desde HTML:", e);
      return {};
    }
  }

  function saveInProgress() {
    try {
      // Mantener sincronizado con la variable global para que se vuelque al guardar el HTML
      window.INITIAL_INPROGRESS = inProgressState;
    } catch (e) {
      console.warn("No se pudo guardar estado 'en curso' en memoria HTML:", e);
    }
  }

		
	
  function saveHtmlToFile() {
	  try {
		// Clonamos el HTML actual del documento (estado actual)
		let htmlText = document.documentElement.outerHTML;

		// Actualizamos la posici√≥n de cada quest en el bloque "quests"
		quests.forEach(q => {
		  if (!q.position) return;
		  const id = q.id;
		  const marker = 'id: "' + id + '"';
		  const idIndex = htmlText.indexOf(marker);
		  if (idIndex === -1) return;

		  const posIndex = htmlText.indexOf("position:", idIndex);
		  if (posIndex === -1) return;

		  const braceStart = htmlText.indexOf("{", posIndex);
		  const braceEnd = htmlText.indexOf("}", braceStart);
		  if (braceStart === -1 || braceEnd === -1) return;

		  const before = htmlText.slice(0, braceStart);
		  const after = htmlText.slice(braceEnd + 1);
		  const newPos = `{ x: ${q.position.x}, y: ${q.position.y} }`;
		  htmlText = before + newPos + after;
		});

		// Actualizamos tambi√©n los datos de curvas (edgeLayout) embebidos en el HTML
		const edgeMarker = "window.INITIAL_EDGE_LAYOUT = ";
		const edgeIndex = htmlText.indexOf(edgeMarker);
		if (edgeIndex !== -1) {
		  const start = edgeIndex + edgeMarker.length;
		  const end = htmlText.indexOf(";", start);
		  if (end !== -1) {
			const beforeEdge = htmlText.slice(0, start);
			const afterEdge = htmlText.slice(end);
			const edgeJson = JSON.stringify(edgeLayout || {});
			htmlText = beforeEdge + edgeJson + afterEdge;
		  }
		}

		// Actualizamos tambi√©n el estado de progreso (completionState) embebido en el HTML
		const compMarker = "window.INITIAL_COMPLETION = ";
		const compIndex = htmlText.indexOf(compMarker);
		if (compIndex !== -1) {
		  const startC = compIndex + compMarker.length;
		  const endC = htmlText.indexOf(";", startC);
		  if (endC !== -1) {
			const beforeC = htmlText.slice(0, startC);
			const afterC = htmlText.slice(endC);
			const compJson = JSON.stringify(completionState || {});
			htmlText = beforeC + compJson + afterC;
		  }
		}

		// Actualizamos tambi√©n el estado 'en curso' embebido en el HTML
		const inprogMarker = "window.INITIAL_INPROGRESS = ";
		const inprogIndex = htmlText.indexOf(inprogMarker);
		if (inprogIndex !== -1) {
		  const startI = inprogIndex + inprogMarker.length;
		  const endI = htmlText.indexOf(";", startI);
		  if (endI !== -1) {
			const beforeI = htmlText.slice(0, startI);
			const afterI = htmlText.slice(endI);
			const inprogJson = JSON.stringify(inProgressState || {});
			htmlText = beforeI + inprogJson + afterI;
		  }
		}

		// Limpia el contenido del SVG (nodos y flechas dibujados en tiempo de ejecuci√≥n)
		// para que el nuevo HTML vuelva a generarlos desde el array "quests"
		const svgMarker = '<svg id="quest-svg"';
		const svgStart = htmlText.indexOf(svgMarker);
		if (svgStart !== -1) {
		  const openEnd = htmlText.indexOf('>', svgStart);
		  const closeIdx = htmlText.indexOf('</svg>', openEnd);
		  if (openEnd !== -1 && closeIdx !== -1) {
			const before = htmlText.slice(0, openEnd + 1);
			const after = htmlText.slice(closeIdx);
			htmlText = before + '</svg>' + after;
		  }
		}

		// Descargar archivo
		const blob = new Blob([htmlText], { type: "text/html" });
		const url = URL.createObjectURL(blob);
		const a = document.createElement("a");
		a.href = url;
		a.download = "tarkov_quests_saved.html";
		document.body.appendChild(a);
		a.click();
		setTimeout(() => {
		  document.body.removeChild(a);
		  URL.revokeObjectURL(url);
		}, 0);
	  } catch (e) {
		console.warn("No se pudo generar el HTML:", e);
		alert("Error al generar el HTML. Revisa la consola.");
	  }
	}



  function isCompleted(id) { return !!completionState[id]; }

  function setCompleted(id, value) {
    completionState[id] = !!value;
    saveCompletion();

    if (value && inProgressState[id]) {
      delete inProgressState[id];
      saveInProgress();
    }

    updateNodeVisual(id);
  }

  function isInProgress(id) { return !!inProgressState[id]; }

  function setInProgress(id, value) {
    if (value) {
      inProgressState[id] = true;
      if (completionState[id]) {
        completionState[id] = false;
        saveCompletion();
      }
    } else {
      delete inProgressState[id];
    }
    saveInProgress();
    updateNodeVisual(id);
  }

  function createNode(q) {
  const g = document.createElementNS(ns, "g");
  g.classList.add("quest-node");
  if (q.traderColor) g.classList.add(q.traderColor);
  g.dataset.id = q.id;

  const completed = isCompleted(q.id);
  const inProg = isInProgress(q.id);

  if (completed) {
    g.classList.add("completed");
  } else if (inProg) {
    g.classList.add("in-progress");
  }

  const x = q.position.x;
  const y = q.position.y;
  g.setAttribute("transform", `translate(${x}, ${y})`);

  const rect = document.createElementNS(ns, "rect");
  rect.setAttribute("width", nodeWidth);
  rect.setAttribute("height", nodeHeight);
  g.appendChild(rect);

  // --- Retrato del trader en todas sus quests ---
  if (traderPortraits[q.trader]) {
    const img = document.createElementNS(ns, "image");
    img.classList.add("trader-portrait");
    // Compatibilidad: establecemos tanto href como xlink:href
    img.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", traderPortraits[q.trader]);
    img.setAttributeNS(null, "href", traderPortraits[q.trader]);
    const portraitSize = 32;
    const portraitX = nodeWidth - portraitSize - 8;
    const portraitY = 8;
    img.setAttribute("x", portraitX);
    img.setAttribute("y", portraitY);
    img.setAttribute("width", portraitSize);
    img.setAttribute("height", portraitSize);
    img.setAttribute("clip-path", "url(#portrait-clip)");
    img.style.pointerEvents = "none";
    g.appendChild(img);
  }

  // ===== T√çTULO (ES ARRIBA, EN ABAJO, SIEMPRE EN L√çNEAS SEPARADAS) =====
  const title = document.createElementNS(ns, "text");
  title.setAttribute("x", 10);
  title.setAttribute("y", 16);

  const rawName = (q.nombre || "").replace(/\r/g, "");
  let main = rawName.trim();
  let extra = null;

  const newlineIdx = rawName.indexOf("\n");
  const parenIdx = rawName.indexOf(" (");

  if (newlineIdx !== -1 && (parenIdx === -1 || newlineIdx < parenIdx)) {
    main = rawName.slice(0, newlineIdx).trim();
    extra = rawName.slice(newlineIdx + 1).trim();
  } else if (parenIdx !== -1) {
    main = rawName.slice(0, parenIdx).trim();
    extra = rawName.slice(parenIdx).trim();
  }

  let titleLines = 0;

  const tspanMain = document.createElementNS(ns, "tspan");
  tspanMain.textContent = main;
  title.appendChild(tspanMain);
  titleLines++;

  // Envolvemos el nombre en ingl√©s si es demasiado largo
  if (extra) {
    const maxCharsPerLine = 34;
    const maxExtraLines = 2;
    const words = extra.split(/\s+/).filter(w => w.length > 0);
    let current = "";
    let lineIndex = 0;

    const pushLine = (text, isFirstExtra) => {
      const t = document.createElementNS(ns, "tspan");
      t.setAttribute("x", 10);
      t.setAttribute("dy", isFirstExtra ? "14" : "11");
      t.textContent = text;
      title.appendChild(t);
      titleLines++;
    };

    for (let i = 0; i < words.length; i++) {
      const w = words[i];
      const test = current ? current + " " + w : w;
      if (test.length > maxCharsPerLine && current) {
        pushLine(current, lineIndex === 0);
        lineIndex++;
        if (lineIndex >= maxExtraLines) {
          if (i < words.length) {
            let remaining = words.slice(i).join(" ");
            if (remaining.length > maxCharsPerLine - 1) {
              remaining = remaining.slice(0, maxCharsPerLine - 1) + "‚Ä¶";
            }
            pushLine(remaining, false);
          }
          current = "";
          break;
        }
        current = w;
      } else {
        current = test;
      }
    }
    if (current && lineIndex < maxExtraLines) {
      pushLine(current, lineIndex === 0);
    }
  }

  g.appendChild(title);

  // ===== NIVEL =====
  const hasSecondLine = titleLines > 1;
  let levelY = hasSecondLine ? 24 + titleLines * 10 : 34;
  if (q.nivel != null) {
    const levelText = document.createElementNS(ns, "text");
    levelText.setAttribute("x", 10);
    levelText.setAttribute("y", levelY);
    levelText.textContent = `Nv. ${q.nivel}`;
    levelText.setAttribute("class", "node-level");
    g.appendChild(levelText);
  }

  // ===== TRADER =====
  let traderYBase = q.nivel != null ? 42 : 30;
  let traderY = traderYBase + (titleLines - 1) * 8;

  const traderText = document.createElementNS(ns, "text");
  traderText.setAttribute("x", 10);
  traderText.setAttribute("y", traderY);
  traderText.textContent = q.trader;
  traderText.setAttribute("class", "node-trader");
  g.appendChild(traderText);

  // ===== CHECK =====
  const checkText = document.createElementNS(ns, "text");
  checkText.setAttribute("x", nodeWidth - 16);
  checkText.setAttribute("y", 18);
  checkText.textContent = "‚úî";
  checkText.setAttribute("class", "node-check");
  if (!completed) checkText.style.opacity = "0";
  g.appendChild(checkText);

  svg.appendChild(g);
}
function drawEdge(fromQ, toQ) {
	  const startX = fromQ.position.x + nodeWidth;
	  const startY = fromQ.position.y + nodeHeight / 2;
	  const endX = toQ.position.x;
	  const endY = toQ.position.y + nodeHeight / 2;

	  const dx = endX - startX;
	  const dy = endY - startY;

	  // Consideramos "especial" una flecha muy larga / muy diagonal
	  const isLong = Math.abs(dx) > nodeWidth * 2 || Math.abs(dy) > nodeHeight * 2;

	  let cls = "quest-edge";
	  if (isLong) {
		cls += " quest-edge-special";
	  }

	  const edgeKey = fromQ.id + "->" + toQ.id;
	  let ctrl = edgeLayout[edgeKey];
	  if (!ctrl) {
		ctrl = {
		  cx: (startX + endX) / 2,
		  cy: (startY + endY) / 2
		};
	  }

	  const path = document.createElementNS(ns, "path");
	  path.setAttribute("d", `M ${startX} ${startY} Q ${ctrl.cx} ${ctrl.cy} ${endX} ${endY}`);
	  path.setAttribute("class", cls);
	  path.dataset.edgeKey = edgeKey;
	  path.dataset.edgePart = "path";
	  svg.insertBefore(path, svg.firstChild);

	  const arrowSize = 6;
	  const angle = Math.atan2(endY - ctrl.cy, endX - ctrl.cx);
	  const ax = endX;
	  const ay = endY;
	  const p2x = ax - arrowSize * Math.cos(angle - Math.PI / 6);
	  const p2y = ay - arrowSize * Math.sin(angle - Math.PI / 6);
	  const p3x = ax - arrowSize * Math.cos(angle + Math.PI / 6);
	  const p3y = ay - arrowSize * Math.sin(angle + Math.PI / 6);
	  const arrow = document.createElementNS(ns, "polygon");
	  arrow.setAttribute("points", `${ax},${ay} ${p2x},${p2y} ${p3x},${p3y}`);
	  arrow.setAttribute("class", cls);
	  // El cuerpo de la flecha se rellena expl√≠citamente,
	  // aunque la curva use fill:none en CSS
	  arrow.setAttribute("fill", isLong ? "#f6c177" : getComputedStyle(svg).getPropertyValue('--edge') || '#f6c177');	  arrow.dataset.edgeKey = edgeKey;
	  arrow.dataset.edgePart = "arrow";
	  svg.insertBefore(arrow, svg.firstChild);

	  const handle = document.createElementNS(ns, "circle");
	  handle.setAttribute("class", "edge-handle");
	  handle.setAttribute("r", 4);
	  handle.setAttribute("cx", ctrl.cx);
	  handle.setAttribute("cy", ctrl.cy);
	  handle.dataset.edgeKey = edgeKey;
	  handle.dataset.edgePart = "handle";
	  svg.insertBefore(handle, svg.firstChild);
	}

  function updateNodeVisual(id) {
    const g = svg.querySelector(`.quest-node[data-id="${id}"]`);
    if (!g) return;

    const completed = isCompleted(id);
    const inProg = isInProgress(id);

    g.classList.toggle("completed", completed);
    g.classList.toggle("in-progress", !completed && inProg);

    const check = g.querySelector(".node-check");
    if (check) check.style.opacity = completed ? "1" : "0";
  }

  quests.forEach(createNode);
	drawAllEdges();
	enableDrag();   // üëà lo a√±adiremos ahora
  setupLevelFilterUI();
  applyLevelFilter();
  setupSearchUI();

	function drawAllEdges() {
	  // borrar edges antiguos
	  [...svg.querySelectorAll(".quest-edge")].forEach(el => el.remove());

	  // volver a dibujar todas las flechas seg√∫n las posiciones actuales
	  quests.forEach(q => {
		(q.prereqIds || []).forEach(pid => {
		  const fromQ = questsById[pid];
		  if (fromQ) drawEdge(fromQ, q);
		});
	  });
	}

	
  // --- Selecci√≥n m√∫ltiple ---
  const selectedIds = new Set();

  function setSelection(ids) {
    selectedIds.clear();
    ids.forEach(id => selectedIds.add(id));
    updateSelectionClasses();
  }

  function toggleSelection(id) {
    if (selectedIds.has(id)) {
      selectedIds.delete(id);
    } else {
      selectedIds.add(id);
    }
    updateSelectionClasses();
  }

  function clearSelection() {
    selectedIds.clear();
    updateSelectionClasses();
  }

  function updateSelectionClasses() {
    svg.querySelectorAll(".quest-node").forEach(g => {
      const id = g.dataset.id;
      if (selectedIds.has(id)) g.classList.add("selected");
      else g.classList.remove("selected");
    });

    // Resaltar prerequisitos y sucesoras cuando hay una √∫nica quest seleccionada
    if (selectedIds.size === 1) {
      const onlyId = Array.from(selectedIds)[0];
      highlightRelations(onlyId);
    } else {
      clearRelationHighlight();
    }
  }
  
    // --- Selecci√≥n por ventana (marquee) ---
  let isBoxSelecting = false;
  let selectionRect = null;
  let boxStartX = 0;
  let boxStartY = 0;
  let boxSelectionAdditive = false; // true si se inici√≥ con Ctrl/Meta pulsado

  function startBoxSelection(e) {
    // Solo bot√≥n izquierdo
    if (e.button !== 0) return;

    // Si se mantiene Ctrl (o Cmd), la selecci√≥n ser√° aditiva
    boxSelectionAdditive = !!(e.ctrlKey || e.metaKey);

    const svgRect = svg.getBoundingClientRect();
    boxStartX = e.clientX - svgRect.left;
    boxStartY = e.clientY - svgRect.top;

    isBoxSelecting = true;

    selectionRect = document.createElementNS(ns, "rect");
    selectionRect.setAttribute("class", "selection-rect");
    selectionRect.setAttribute("x", boxStartX);
    selectionRect.setAttribute("y", boxStartY);
    selectionRect.setAttribute("width", 0);
    selectionRect.setAttribute("height", 0);
    selectionRect.setAttribute("rx", 4);
    selectionRect.setAttribute("ry", 4);
    selectionRect.style.pointerEvents = "none";

    svg.appendChild(selectionRect);
  }

  function updateBoxSelection(e) {
    if (!isBoxSelecting || !selectionRect) return;

    const svgRect = svg.getBoundingClientRect();
    const currentX = e.clientX - svgRect.left;
    const currentY = e.clientY - svgRect.top;

    const x = Math.min(currentX, boxStartX);
    const y = Math.min(currentY, boxStartY);
    const w = Math.abs(currentX - boxStartX);
    const h = Math.abs(currentY - boxStartY);

    selectionRect.setAttribute("x", x);
    selectionRect.setAttribute("y", y);
    selectionRect.setAttribute("width", w);
    selectionRect.setAttribute("height", h);
  }

  function finishBoxSelection() {
    if (!isBoxSelecting) return;
    isBoxSelecting = false;

    if (!selectionRect) return;

    const rectX = parseFloat(selectionRect.getAttribute("x"));
    const rectY = parseFloat(selectionRect.getAttribute("y"));
    const rectW = parseFloat(selectionRect.getAttribute("width"));
    const rectH = parseFloat(selectionRect.getAttribute("height"));

    selectionRect.remove();
    selectionRect = null;

    // Si pr√°cticamente no se ha arrastrado, no hacemos nada especial
    if (rectW < 3 && rectH < 3) {
      return;
    }

    // Convertimos a coordenadas "de mundo" teniendo en cuenta el zoom
    const scale = (typeof zoom === "number" && zoom > 0) ? zoom : 1;
    const minX = rectX / scale;
    const minY = rectY / scale;
    const maxX = (rectX + rectW) / scale;
    const maxY = (rectY + rectH) / scale;

    const newlySelected = [];

    quests.forEach(q => {
      if (!q.position) return;

      const x1 = q.position.x;
      const y1 = q.position.y;
      const x2 = x1 + nodeWidth;
      const y2 = y1 + nodeHeight;

      // Si cualquier parte del nodo intersecta la ventana
      const intersects =
        x2 >= minX && x1 <= maxX &&
        y2 >= minY && y1 <= maxY;

      if (intersects) {
        newlySelected.push(q.id);
      }
    });

    if (boxSelectionAdditive) {
      const combined = new Set(selectedIds);
      newlySelected.forEach(id => combined.add(id));
      setSelection(Array.from(combined));
    } else {
      setSelection(newlySelected);
    }

    boxSelectionAdditive = false;
  }

  
  function getConnectedQuestIds(rootId) {
    const result = new Set();
    const queue = [rootId];
    result.add(rootId);

    while (queue.length > 0) {
      const currentId = queue.shift();
      const currentQuest = questsById[currentId];
      if (!currentQuest) continue;

      // 1) Prerequisitos del nodo actual
      (currentQuest.prereqIds || []).forEach(pid => {
        if (!result.has(pid)) {
          result.add(pid);
          queue.push(pid);
        }
      });

      // 2) Sucesoras: quests que tienen a currentId como prerequisito
      quests.forEach(q => {
        if (!q.prereqIds) return;
        if (q.prereqIds.includes(currentId) && !result.has(q.id)) {
          result.add(q.id);
          queue.push(q.id);
        }
      });
    }

    return Array.from(result);
  }




  // --- Historial de deshacer movimientos de quests y curvas ---
  const undoStack = [];
  const UNDO_LIMIT = 50;

  function pushUndoMove(items) {
    undoStack.push({ type: "move", items });
    if (undoStack.length > UNDO_LIMIT) {
      undoStack.shift();
    }
  }

  function pushUndoEdge(key, fromCX, fromCY, toCX, toCY) {
    undoStack.push({
      type: "edge",
      key,
      from: { cx: fromCX, cy: fromCY },
      to: { cx: toCX, cy: toCY }
    });
    if (undoStack.length > UNDO_LIMIT) {
      undoStack.shift();
    }
  }

  // Se mantiene el nombre undoLastMove porque ya lo usa Ctrl+Z,
  // pero ahora deshace movimientos de nodos y tambi√©n curvas.
  function undoLastMove() {
    const last = undoStack.pop();
    if (!last) return;

    if (last.type === "move") {
      last.items.forEach(entry => {
        const q = questsById[entry.id];
        const node = svg.querySelector(`.quest-node[data-id="${entry.id}"]`);
        if (!q || !node) return;
        q.position.x = entry.from.x;
        q.position.y = entry.from.y;
        node.setAttribute("transform", `translate(${entry.from.x}, ${entry.from.y})`);
      });

      drawAllEdges();
    } else if (last.type === "edge") {
      const key = last.key;
      const from = last.from;

      if (from && typeof from.cx === "number" && typeof from.cy === "number") {
        edgeLayout[key] = { cx: from.cx, cy: from.cy };
      } else {
        delete edgeLayout[key];
      }

      const handle = svg.querySelector(`.edge-handle[data-edge-key="${key}"]`);
      const parts = key.split("->");
      const fromQ = questsById[parts[0]];
      const toQ = questsById[parts[1]];

      if (fromQ && toQ) {
        const localX = from.cx;
        const localY = from.cy;

        if (handle) {
          handle.setAttribute("cx", localX);
          handle.setAttribute("cy", localY);
        }

        const startX = fromQ.position.x + nodeWidth;
        const startY = fromQ.position.y + nodeHeight / 2;
        const endX = toQ.position.x;
        const endY = toQ.position.y + nodeHeight / 2;

        const pathEl = svg.querySelector(`path.quest-edge[data-edge-key="${key}"]`);
        if (pathEl) {
          pathEl.setAttribute("d", `M ${startX} ${startY} Q ${localX} ${localY} ${endX} ${endY}`);
        }

        const arrowEl = svg.querySelector(`polygon.quest-edge[data-edge-key="${key}"]`);
        if (arrowEl) {
          const arrowSize = 6;
          const angle = Math.atan2(endY - localY, endX - localX);
          const ax = endX;
          const ay = endY;
          const p2x = ax - arrowSize * Math.cos(angle - Math.PI / 6);
          const p2y = ay - arrowSize * Math.sin(angle - Math.PI / 6);
          const p3x = ax - arrowSize * Math.cos(angle + Math.PI / 6);
          const p3y = ay - arrowSize * Math.sin(angle + Math.PI / 6);
          arrowEl.setAttribute("points", `${ax},${ay} ${p2x},${p2y} ${p3x},${p3y}`);
        }
      }

      saveEdgeLayout();
    }
  }


  // Restablecer una flecha a l√≠nea recta (control en posici√≥n por defecto)
  function resetEdgeToDefault(key, recordUndo = true) {
    const ctrl = edgeLayout[key];
    // Si no hay control personalizado, ya es recta por defecto
    if (!ctrl || typeof ctrl.cx !== "number" || typeof ctrl.cy !== "number") {
      return;
    }

    const parts = key.split("->");
    const fromQ = questsById[parts[0]];
    const toQ = questsById[parts[1]];
    if (!fromQ || !toQ) return;

    const startX = fromQ.position.x + nodeWidth;
    const startY = fromQ.position.y + nodeHeight / 2;
    const endX = toQ.position.x;
    const endY = toQ.position.y + nodeHeight / 2;

    const prevCX = ctrl.cx;
    const prevCY = ctrl.cy;

    // Posici√≥n "recta": punto medio del segmento
    const ctrlX = (startX + endX) / 2;
    const ctrlY = (startY + endY) / 2;

    // Eliminamos el layout personalizado para este edge
    delete edgeLayout[key];

    const handle = svg.querySelector(`.edge-handle[data-edge-key="${key}"]`);
    if (handle) {
      handle.setAttribute("cx", ctrlX);
      handle.setAttribute("cy", ctrlY);
    }

    const pathEl = svg.querySelector(`path.quest-edge[data-edge-key="${key}"]`);
    if (pathEl) {
      pathEl.setAttribute("d", `M ${startX} ${startY} Q ${ctrlX} ${ctrlY} ${endX} ${endY}`);
    }

    const arrowEl = svg.querySelector(`polygon.quest-edge[data-edge-key="${key}"]`);
    if (arrowEl) {
      const arrowSize = 6;
      const angle = Math.atan2(endY - ctrlY, endX - ctrlX);
      const ax = endX;
      const ay = endY;
      const p2x = ax - arrowSize * Math.cos(angle - Math.PI / 6);
      const p2y = ay - arrowSize * Math.sin(angle - Math.PI / 6);
      const p3x = ax - arrowSize * Math.cos(angle + Math.PI / 6);
      const p3y = ay - arrowSize * Math.sin(angle + Math.PI / 6);
      arrowEl.setAttribute("points", `${ax},${ay} ${p2x},${p2y} ${p3x},${p3y}`);
    }

    if (recordUndo) {
      pushUndoEdge(key, prevCX, prevCY, ctrlX, ctrlY);
    }

    saveEdgeLayout();
  }

function enableDrag() {
    let dragging = false;
    let anchorNode = null;
    let anchorQuest = null;
    let dragGroup = [];
    let startMouseX = 0;
    let startMouseY = 0;
    let offsetX = 0;
    let offsetY = 0;
    let clickHandled = false;
    let lastDownUsedModifier = false;
    let movedDuringDrag = false;

    let edgeDrag = null;

    const SNAP_DIST = 12;

    function getTranslate(g) {
      const tr = g.getAttribute("transform") || "";
      const m = /translate\(([-\d.]+),\s*([\-\d.]+)\)/.exec(tr);
      if (!m) return { x: 0, y: 0 };
      return { x: parseFloat(m[1]), y: parseFloat(m[2]) };
    }

    svg.addEventListener("mousedown", (e) => {
      const handle = e.target.closest(".edge-handle");
      if (handle) {
        const key = handle.dataset.edgeKey;
        const cx = parseFloat(handle.getAttribute("cx"));
        const cy = parseFloat(handle.getAttribute("cy"));
        edgeDrag = {
          key,
          handle,
          startCX: cx,
          startCY: cy,
          startMouseX: e.clientX,
          startMouseY: e.clientY
        };
        return;
      }

      // En modo edici√≥n de flechas, Shift+click sobre una flecha
      // restablece la curva a l√≠nea recta (control por defecto)
      if (document.body.classList.contains("edge-edit-mode") && e.shiftKey) {
        const edgeEl = e.target.closest("path.quest-edge, polygon.quest-edge");
        if (edgeEl && edgeEl.dataset.edgeKey) {
          resetEdgeToDefault(edgeEl.dataset.edgeKey, true);
          e.preventDefault();
          return;
        }
      }

      // En modo edici√≥n de flechas, click normal sobre una flecha
      // la selecciona y muestra √∫nicamente su punto de control
      if (document.body.classList.contains("edge-edit-mode") && !e.shiftKey) {
        const edgeEl = e.target.closest("path.quest-edge, polygon.quest-edge");
        if (edgeEl && edgeEl.dataset.edgeKey) {
          selectEdgeForEditing(edgeEl.dataset.edgeKey);
          e.preventDefault();
          return;
        }
      }

      const g = e.target.closest(".quest-node");
      if (!g) {
        // Click/drag en el fondo ‚Üí iniciar selecci√≥n por ventana
        if (!(e.ctrlKey || e.metaKey)) {
          clearSelection();
        }
        startBoxSelection(e);
        return;
      }

      const id = g.dataset.id;
      const quest = questsById[id];
      if (!quest) return;

      // --- Selecci√≥n seg√∫n modificadores ---
      if (e.ctrlKey && e.shiftKey) {
        // Ctrl+Shift+click ‚Üí seleccionar TODA la cadena conectada por flechas
        const ids = getConnectedQuestIds(id);
        setSelection(ids);
        lastDownUsedModifier = true;
      } else if (e.ctrlKey || e.shiftKey) {
        // Ctrl O Shift solo ‚Üí selecci√≥n m√∫ltiple normal (como antes)
        toggleSelection(id);
        lastDownUsedModifier = true;
      } else {
        // Click normal ‚Üí solo esta quest
        if (!selectedIds.has(id) || selectedIds.size === 0) {
          setSelection([id]);
        }
        lastDownUsedModifier = false;
      }

      // A PARTIR DE AQU√ç CALCULAMOS EL GRUPO A ARRASTRAR
      const groupIds = selectedIds.size > 0 ? Array.from(selectedIds) : [id];

      dragGroup = groupIds.map(gid => {
        const q = questsById[gid];
        const node = svg.querySelector(`.quest-node[data-id="${gid}"]`);
        const tr = getTranslate(node);
        return { quest: q, node, startX: tr.x, startY: tr.y };
      });

      anchorNode = g;
      anchorQuest = quest;
      const anchorPos = getTranslate(anchorNode);

      const svgRect = svg.getBoundingClientRect();
      offsetX = e.clientX - (svgRect.left + anchorPos.x);
      offsetY = e.clientY - (svgRect.top + anchorPos.y);
      startMouseX = e.clientX;
      startMouseY = e.clientY;

      dragging = true;
      clickHandled = false;
      movedDuringDrag = false;
      e.preventDefault();
    });

    window.addEventListener("mousemove", (e) => {
      if (edgeDrag) {
        const svgRect = svg.getBoundingClientRect();
        const localX = e.clientX - svgRect.left;
        const localY = e.clientY - svgRect.top;

        const key = edgeDrag.key;
        edgeLayout[key] = { cx: localX, cy: localY };

        edgeDrag.handle.setAttribute("cx", localX);
        edgeDrag.handle.setAttribute("cy", localY);

        const parts = key.split("->");
        const fromQ = questsById[parts[0]];
        const toQ = questsById[parts[1]];
        if (fromQ && toQ) {
          const startX = fromQ.position.x + nodeWidth;
          const startY = fromQ.position.y + nodeHeight / 2;
          const endX = toQ.position.x;
          const endY = toQ.position.y + nodeHeight / 2;
          const pathEl = svg.querySelector(`path.quest-edge[data-edge-key="${key}"]`);
          if (pathEl) {
            pathEl.setAttribute("d", `M ${startX} ${startY} Q ${localX} ${localY} ${endX} ${endY}`);
          }
          const arrowEl = svg.querySelector(`polygon.quest-edge[data-edge-key="${key}"]`);
          if (arrowEl) {
            const arrowSize = 6;
            const angle = Math.atan2(endY - localY, endX - localX);
            const ax = endX;
            const ay = endY;
            const p2x = ax - arrowSize * Math.cos(angle - Math.PI / 6);
            const p2y = ay - arrowSize * Math.sin(angle - Math.PI / 6);
            const p3x = ax - arrowSize * Math.cos(angle + Math.PI / 6);
            const p3y = ay - arrowSize * Math.sin(angle + Math.PI / 6);
            arrowEl.setAttribute("points", `${ax},${ay} ${p2x},${p2y} ${p3x},${p3y}`);
          }
        }
        return;
      }

      // Si estamos dibujando la ventana de selecci√≥n, actualizamos y salimos
      if (isBoxSelecting) {
        updateBoxSelection(e);
        return;
      }

      if (!dragging || !anchorNode || dragGroup.length === 0) return;

      const dxMouse = e.clientX - startMouseX;
      const dyMouse = e.clientY - startMouseY;

      if (!clickHandled && Math.abs(dxMouse) < 3 && Math.abs(dyMouse) < 3) {
        return;
      }
      clickHandled = true;

      const svgRect = svg.getBoundingClientRect();

      let anchorNewX = e.clientX - svgRect.left - offsetX;
      let anchorNewY = e.clientY - svgRect.top - offsetY;

      let snapX = anchorNewX;
      let snapY = anchorNewY;

      quests.forEach(q => {
        if (!q.position) return;
        if (dragGroup.some(d => d.quest.id === q.id)) return;

        if (Math.abs(snapX - q.position.x) < SNAP_DIST) {
          snapX = q.position.x;
        }
        if (Math.abs(snapY - q.position.y) < SNAP_DIST) {
          snapY = q.position.y;
        }
      });

      anchorNewX = snapX;
      anchorNewY = snapY;

      const anchorStart = dragGroup.find(d => d.quest.id === anchorQuest.id);
      const deltaX = anchorNewX - anchorStart.startX;
      const deltaY = anchorNewY - anchorStart.startY;

      dragGroup.forEach(d => {
        const newX = d.startX + deltaX;
        const newY = d.startY + deltaY;
        d.quest.position.x = newX;
        d.quest.position.y = newY;
        d.node.setAttribute("transform", `translate(${newX}, ${newY})`);
      });

      movedDuringDrag = true;
      drawAllEdges();
    });


        window.addEventListener("mouseup", () => {
      if (edgeDrag) {
        const key = edgeDrag.key;
        const startCX = edgeDrag.startCX;
        const startCY = edgeDrag.startCY;
        const handle = edgeDrag.handle;
        const endCX = parseFloat(handle.getAttribute("cx"));
        const endCY = parseFloat(handle.getAttribute("cy"));
        if (startCX !== endCX || startCY !== endCY) {
          pushUndoEdge(key, startCX, startCY, endCX, endCY);
        }
        saveEdgeLayout();
        edgeDrag = null;
        return;
      }

      // Si est√°bamos en selecci√≥n por ventana, terminarla y salir
      if (isBoxSelecting) {
        finishBoxSelection();
        return;
      }

      if (!dragging || !anchorQuest) return;

      if (!clickHandled) {
        if (!lastDownUsedModifier) {
          openModal(anchorQuest.id);
        }
      } else {
        if (movedDuringDrag && dragGroup.length > 0) {
          const items = dragGroup.map(d => ({
            id: d.quest.id,
            from: { x: d.startX, y: d.startY },
            to: { x: d.quest.position.x, y: d.quest.position.y }
          }));
          pushUndoMove(items);
        }
      }

      dragging = false;
      anchorNode = null;
      anchorQuest = null;
      dragGroup = [];
      clickHandled = false;
      lastDownUsedModifier = false;
      movedDuringDrag = false;
    });
  }





  // Modal
  const modal = document.getElementById("quest-modal");
  const backdrop = document.getElementById("modal-backdrop");
  const modalTitle = document.getElementById("modal-title");
  const modalTrader = document.getElementById("modal-trader");
  const modalChip = document.getElementById("modal-chip");
  const modalChipDot = modalChip.querySelector(".dot");
  const modalChipText = document.getElementById("modal-chip-text");
  const modalDesc = document.getElementById("modal-desc");
  const edgeModeIndicator = document.getElementById("edge-edit-indicator");
  const modalObjectives = document.getElementById("modal-objectives");
  const modalRewards = document.getElementById("modal-rewards");
  const modalCompleted = document.getElementById("modal-completed");
  const modalInProgress = document.getElementById("modal-inprogress");
  const modalYoutube = document.getElementById("modal-youtube");
  const modalClose = document.getElementById("modal-close");
  const helpToggle = document.getElementById("help-toggle");
  const helpPanel = document.getElementById("help-panel");
  let currentQuestId = null;
  let currentEnglishTitle = null;

  // Extrae el nombre en ingl√©s de "15. Documentos (Documents)"
  function getEnglishTitle(fullName) {
    if (!fullName) return null;
    const open = fullName.lastIndexOf("(");
    const close = fullName.lastIndexOf(")");
    if (open === -1 || close === -1 || close <= open) return null;
    const en = fullName.slice(open + 1, close).trim();
    return en || null;
  }

  function openModal(id) {
    const q = questsById[id];
    if (!q) return;
    currentQuestId = id;

    modalTitle.textContent = q.nombre;
    modalTrader.textContent = q.trader;
    modalDesc.textContent = q.descripcion || "";

    // guardar el t√≠tulo ingl√©s de la quest actual
    currentEnglishTitle = getEnglishTitle(q.nombre);

    modalObjectives.innerHTML = "";
    (q.objetivos || []).forEach(obj => {
      const li = document.createElement("li");
      li.textContent = obj;
      modalObjectives.appendChild(li);
    });

    modalRewards.innerHTML = "";
    (q.recompensas || []).forEach(r => {
      const li = document.createElement("li");
      li.textContent = r;
      modalRewards.appendChild(li);
    });

    modalYoutube.href = q.youtube || "#";

    const completed = isCompleted(id);
    const inProg = isInProgress(id);

    modalCompleted.checked = completed;
    modalInProgress.checked = inProg && !completed;

    updateModalChip();

    modal.classList.add("open");
    backdrop.classList.add("open");
  }

  function closeModal() {
    currentQuestId = null;
    currentEnglishTitle = null;
    modal.classList.remove("open");
    backdrop.classList.remove("open");
  }

  function updateModalChip() {
    if (!currentQuestId) return;
    const q = questsById[currentQuestId];
    const completed = isCompleted(currentQuestId);
    const inProg = isInProgress(currentQuestId);

    if (completed) {
      modalChipDot.className = "dot completed";
      modalChipText.textContent = "Completada";
    } else if (inProg) {
      modalChipDot.className = "dot in-progress";
      modalChipText.textContent = "En curso";
    } else {
      modalChipDot.className = "dot " + (q.traderColor || "");
      modalChipText.textContent = "Pendiente";
    }
  }

  // Marcar completada / no completada desde el modal
  modalCompleted.addEventListener("change", () => {
    if (!currentQuestId) return;
    const val = modalCompleted.checked;
    setCompleted(currentQuestId, val);
    if (val) {
      modalInProgress.checked = false;
    }
    updateModalChip();
  });

  modalInProgress.addEventListener("change", () => {
    if (!currentQuestId) return;
    const val = modalInProgress.checked;
    setInProgress(currentQuestId, val);
    if (val) {
      modalCompleted.checked = false;
    }
    updateModalChip();
  });

  // Botones de cierre del modal
  modalClose.addEventListener("click", closeModal);
  backdrop.addEventListener("click", closeModal);

  if (helpToggle && helpPanel) {
    helpToggle.addEventListener("click", () => {
      helpPanel.classList.toggle("active");
    });
  }

  document.addEventListener("keydown", e => {
    if (e.key === "Escape") {
      closeModal();
      return;
    }

    // Tecla E: alternar modo edici√≥n de flechas
    if (e.key === "e" || e.key === "E") {
      const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
      if (tag === "input" || tag === "textarea") return;
      const enabled = document.body.classList.toggle("edge-edit-mode");
      if (edgeModeIndicator) {
        edgeModeIndicator.classList.toggle("active", enabled);
      }
      if (!enabled) {
        currentEditedEdgeKey = null;
        svg.querySelectorAll(".quest-edge-selected").forEach(el => {
          el.classList.remove("quest-edge-selected");
        });
        svg.querySelectorAll(".edge-handle.active").forEach(h => {
          h.classList.remove("active");
        });
      } else {
        // al entrar en modo edici√≥n, limpiamos selecci√≥n previa
        currentEditedEdgeKey = null;
        svg.querySelectorAll(".quest-edge-selected").forEach(el => {
          el.classList.remove("quest-edge-selected");
        });
        svg.querySelectorAll(".edge-handle.active").forEach(h => {
          h.classList.remove("active");
        });
      }
    }
  });

  // CLICK EN EL T√çTULO ‚Üí ABRIR WIKI DE TARKOV
  modalTitle.addEventListener("click", () => {
    const enTitle = currentEnglishTitle || getEnglishTitle(modalTitle.textContent);
    if (!enTitle) return;

    const url =
      "https://escapefromtarkov.fandom.com/wiki/Special:Search?query=" +
      encodeURIComponent(enTitle);

    window.open(url, "_blank", "noopener");
  });

  window.addEventListener("keydown", (e) => {
    if ((e.ctrlKey || e.metaKey) && (e.key === "z" || e.key === "Z")) {
      e.preventDefault();
      undoLastMove();
    }
  });

  // Zoom
  const graphInner = document.getElementById("graph-inner");
  let zoom = 1;

  function applyZoom() {
    graphInner.style.transform = `scale(${zoom})`;
  }

  document.getElementById("zoom-in").addEventListener("click", () => {
    zoom = Math.min(1.5, zoom + 0.1);
    applyZoom();
  });

  document.getElementById("zoom-out").addEventListener("click", () => {
    zoom = Math.max(0.6, zoom - 0.1);
    applyZoom();
  });

  applyZoom();

  // Botones de layout
  
  function saveQuestsDataJs() {
    try {
      // Opcional: forzar que las posiciones en memoria est√©n alineadas a la rejilla si existe snapToGrid
      if (typeof snapToGridX === "function" && typeof snapToGridY === "function") {
        quests.forEach(q => {
          if (!q.position) return;
          q.position.x = snapToGridX(q.position.x);
          q.position.y = snapToGridY(q.position.y);
        });
      }

      const data = "const quests = " + JSON.stringify(quests, null, 2) + ";\n";

      const blob = new Blob([data], { type: "text/plain" });
      const url = URL.createObjectURL(blob);

      const a = document.createElement("a");
      a.href = url;
      a.download = "quests_data.txt"; // se descarga como .txt para que Windows no lo bloquee
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);

      URL.revokeObjectURL(url);
    } catch (err) {
      console.error("Error al generar quests_data.txt:", err);
      alert("Error al generar quests_data.txt. Revisa la consola.");
    }
  }


  document.getElementById("save-html").addEventListener("click", () => {
    if (confirm("Se descargar√° un nuevo archivo HTML con las posiciones actuales. ¬øContinuar?")) {
      saveHtmlToFile();
    }
  });

  document.getElementById("save-quests-js").addEventListener("click", () => {
    if (confirm("Se descargar√° un nuevo quests_data.txt con las posiciones actuales. ¬øContinuar?")) {
      saveQuestsDataJs();
    }
  });

  
  

</script>


</body></html>